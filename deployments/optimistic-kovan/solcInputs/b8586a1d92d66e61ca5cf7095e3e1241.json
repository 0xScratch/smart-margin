{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getSynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}"
    },
    "contracts/MarginBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IAddressResolver.sol\";\nimport \"./interfaces/IFuturesMarket.sol\";\nimport \"./interfaces/IFuturesMarketManager.sol\";\nimport \"./interfaces/IExchangeRates.sol\";\nimport \"./utils/OpsReady.sol\";\nimport \"./utils/MinimalProxyable.sol\";\nimport \"./MarginBaseSettings.sol\";\n\n/// @title Kwenta MarginBase Account\n/// @author JaredBorders (jaredborders@proton.me), JChiaramonte7 (jeremy@bytecode.llc)\n/// @notice Flexible, minimalist, and gas-optimized cross-margin enabled account\n/// for managing perpetual futures positions\ncontract MarginBase is MinimalProxyable, OpsReady {\n    /*///////////////////////////////////////////////////////////////\n                                Constants\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice tracking code used when modifying positions\n    bytes32 private constant TRACKING_CODE = \"KWENTA\";\n\n    /// @notice name for futures market manager, needed for fetching market key\n    bytes32 private constant FUTURES_MANAGER = \"FuturesMarketManager\";\n\n    /// @notice max BPS\n    uint256 private constant MAX_BPS = 10000;\n\n    // constant for sUSD currency key\n    bytes32 private constant SUSD = \"sUSD\";\n\n    /*///////////////////////////////////////////////////////////////\n                                Types\n    ///////////////////////////////////////////////////////////////*/\n\n    // marketKey: synthetix futures market id/key\n    // margin: amount of margin (in sUSD) in specific futures market\n    // size: denoted in market currency (i.e. ETH, BTC, etc), size of futures position\n    struct ActiveMarketPosition {\n        bytes32 marketKey;\n        uint128 margin;\n        int128 size;\n    }\n\n    // marketKey: synthetix futures market id/key\n    // marginDelta: amount of margin (in sUSD) to deposit or withdraw\n    // sizeDelta: denoted in market currency (i.e. ETH, BTC, etc), size of futures position\n    // isClosing: indicates if position needs to be closed\n    struct UpdateMarketPositionSpec {\n        bytes32 marketKey;\n        int256 marginDelta; // positive indicates deposit, negative withdraw\n        int256 sizeDelta;\n        bool isClosing; // if true, marginDelta nor sizeDelta are considered. simply closes position\n    }\n\n    // marketKey: synthetix futures market id/key\n    // marginDelta: amount of margin (in sUSD) to deposit or withdraw\n    // sizeDelta: denoted in market currency (i.e. ETH, BTC, etc), size of futures position\n    // desiredPrice: limit or stop price desired\n    // gelatoTaskId: unqiue taskId from gelato necessary for cancelling orders\n    struct Order {\n        bytes32 marketKey;\n        int256 marginDelta; // positive indicates deposit, negative withdraw\n        int256 sizeDelta;\n        uint256 desiredPrice;\n        bytes32 gelatoTaskId;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                State\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice settings for MarginBase account\n    MarginBaseSettings public marginBaseSettings;\n\n    /// @notice synthetix address resolver\n    IAddressResolver private addressResolver;\n\n    /// @notice synthetix futures market manager\n    IFuturesMarketManager private futuresManager;\n\n    /// @notice token contract used for account margin\n    IERC20 public marginAsset;\n\n    /// @notice margin locked for future events (ie. limit orders)\n    uint256 public committedMargin;\n\n    /// @notice market keys that the account has active positions in\n    bytes32[] public activeMarketKeys;\n\n    /// @notice market keys mapped to active market positions\n    mapping(bytes32 => ActiveMarketPosition) public activeMarketPositions;\n\n    /// @notice limit orders\n    mapping(uint256 => Order) public orders;\n\n    /// @notice sequentially id orders\n    uint256 public orderId;\n\n    /*///////////////////////////////////////////////////////////////\n                                Events\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted after a successful deposit\n    /// @param user: the address that deposited into account\n    /// @param amount: amount of marginAsset to deposit into marginBase account\n    event Deposit(address indexed user, uint256 amount);\n\n    /// @notice emitted after a successful withdrawal\n    /// @param user: the address that withdrew from account\n    /// @param amount: amount of marginAsset to withdraw from marginBase account\n    event Withdraw(address indexed user, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                                Errors\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice amount deposited/withdrawn into/from account cannot be zero\n    error AmountCantBeZero();\n\n    /// @notice position with given marketKey does not exist\n    /// @param marketKey: key for synthetix futures market\n    error MissingMarketKey(bytes32 marketKey);\n\n    /// @notice limit size of new position specs passed into distribute margin\n    /// @param numberOfNewPositions: number of new position specs\n    error MaxNewPositionsExceeded(uint256 numberOfNewPositions);\n\n    /// @notice exceeds useable margin\n    /// @param available: amount of useable margin asset\n    /// @param required: amount of margin asset required\n    error InsufficientFreeMargin(uint256 available, uint256 required);\n\n    /*///////////////////////////////////////////////////////////////\n                        Constructor & Initializer\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice constructor never used except for first CREATE\n    // solhint-disable-next-line\n    constructor() MinimalProxyable() {}\n\n    /// @notice initialize contract (only once) and transfer ownership to caller\n    /// @param _marginAsset: token contract address used for account margin\n    /// @param _addressResolver: contract address for synthetix address resolver\n    /// @param _marginBaseSettings: contract address for MarginBase account settings\n    /// @param _ops: gelato ops address\n    function initialize(\n        address _marginAsset,\n        address _addressResolver,\n        address _marginBaseSettings,\n        address payable _ops\n    ) external initOnce {\n        marginAsset = IERC20(_marginAsset);\n        addressResolver = IAddressResolver(_addressResolver);\n        futuresManager = IFuturesMarketManager(\n            addressResolver.requireAndGetAddress(\n                FUTURES_MANAGER,\n                \"MarginBase: Could not get Futures Market Manager\"\n            )\n        );\n        marginAsset = IERC20(_marginAsset);\n\n        /// @dev MarginBaseSettings must exist prior to MarginBase account creation\n        marginBaseSettings = MarginBaseSettings(_marginBaseSettings);\n\n        /// @dev the Ownable constructor is never called when we create minimal proxies\n        _transferOwnership(msg.sender);\n\n        ops = _ops;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                Views\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice get number of active market positions account has\n    /// @return number of positions which are currently active for account\n    function getNumberOfActivePositions() external view returns (uint256) {\n        return activeMarketKeys.length;\n    }\n\n    /// @notice get all active market positions\n    /// @return positions which are currently active for account (ActiveMarketPosition structs)\n    function getAllActiveMarketPositions()\n        external\n        view\n        returns (ActiveMarketPosition[] memory)\n    {\n        ActiveMarketPosition[] memory positions = new ActiveMarketPosition[](\n            activeMarketKeys.length\n        );\n        for (uint16 i = 0; i < activeMarketKeys.length; i++) {\n            positions[i] = (activeMarketPositions[activeMarketKeys[i]]);\n        }\n        return positions;\n    }\n\n    /// @notice the current withdrawable or usable balance\n    function freeMargin() public view returns (uint256) {\n        return marginAsset.balanceOf(address(this)) - committedMargin;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Account Deposit & Withdraw\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @param _amount: amount of marginAsset to deposit into marginBase account\n    function deposit(uint256 _amount) external onlyOwner {\n        /// @notice amount deposited into account cannot be zero\n        if (_amount == 0) {\n            revert AmountCantBeZero();\n        }\n\n        // transfer in margin asset from user\n        // (will revert if user does not have amount specified)\n        require(\n            marginAsset.transferFrom(owner(), address(this), _amount),\n            \"MarginBase: deposit failed\"\n        );\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @param _amount: amount of marginAsset to withdraw from marginBase account\n    function withdraw(uint256 _amount) external onlyOwner {\n        /// @notice amount withdrawn from account cannot be zero\n        if (_amount == 0) {\n            revert AmountCantBeZero();\n        }\n\n        // make sure committed margin isn't withdrawn\n        if (_amount > freeMargin()) {\n            revert InsufficientFreeMargin(freeMargin(), _amount);\n        }\n\n        // transfer out margin asset to user\n        // (will revert if account does not have amount specified)\n        require(\n            marginAsset.transfer(owner(), _amount),\n            \"MarginBase: withdraw failed\"\n        );\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            Margin Distribution\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice distribute margin across all/some positions specified via _newPositions\n    /// @dev _newPositions may contain any number of new or existing positions\n    /// @dev caller can close and withdraw all margin from position if _newPositions[i].isClosing is true\n    /// @param _newPositions: an array of UpdateMarketPositionSpec's used to modify active market positions\n    function distributeMargin(UpdateMarketPositionSpec[] memory _newPositions)\n        external\n        onlyOwner\n    {\n        _distributeMargin(_newPositions);\n    }\n\n    function _distributeMargin(UpdateMarketPositionSpec[] memory _newPositions)\n        internal\n    {\n        /// @notice limit size of new position specs passed into distribute margin\n        if (_newPositions.length > type(uint16).max) {\n            revert MaxNewPositionsExceeded(_newPositions.length);\n        }\n\n        /// @notice tracking variable for calculating fee(s) based on margin delta\n        /// @dev margin delta: total margin deposited/withdrawn across ALL new positions\n        uint256 totalMarginDelta = 0;\n\n        // for each new position in _newPositions, distribute margin accordingly and update state\n        for (uint16 i = 0; i < _newPositions.length; i++) {\n            if (_newPositions[i].isClosing) {\n                /// @notice close position and transfer margin back to account\n                totalMarginDelta += closePositionAndWithdraw(\n                    _newPositions[i].marketKey\n                );\n            } else if (_newPositions[i].marginDelta < 0) {\n                /// @notice remove margin from market and potentially adjust size\n                totalMarginDelta += modifyPositionForMarketAndWithdraw(\n                    _newPositions[i].marginDelta,\n                    _newPositions[i].sizeDelta,\n                    _newPositions[i].marketKey\n                );\n            } else {\n                /// @dev marginDelta >= 0\n                /// @notice deposit margin into market and potentially adjust size\n                totalMarginDelta += depositAndModifyPositionForMarket(\n                    _newPositions[i].marginDelta,\n                    _newPositions[i].sizeDelta,\n                    _newPositions[i].marketKey\n                );\n                // if marginDelta is 0, there will simply be NO additional\n                // margin deposited into the market\n            }\n        }\n\n        /// @notice impose fee: send fee to Kwenta's treasury IF margin was deposited/withdrawn\n        if (totalMarginDelta > 0) {\n            require(\n                marginAsset.transfer(\n                    marginBaseSettings.treasury(),\n                    (totalMarginDelta * marginBaseSettings.distributionFee()) /\n                        MAX_BPS\n                ),\n                \"MarginBase: unable to pay fee\"\n            );\n        }\n    }\n\n    // @TODO https://github.com/Kwenta/margin-manager/issues/12\n\n    /*///////////////////////////////////////////////////////////////\n                    Internal Margin Distribution\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice deposit margin into specific market, creating/adding to a position\n    /// @dev _depositSize can NEVER be negative\n    /// @dev both _depositSize and _sizeDelta could be zero (i.e. market position goes unchanged)\n    /// @param _depositSize: size of deposit in sUSD\n    /// @param _sizeDelta: size and position type (long//short) denoted in market synth (ex: sETH)\n    /// @param _marketKey: synthetix futures market id/key\n    /// @return marginMoved total margin moved in function call \n    function depositAndModifyPositionForMarket(\n        int256 _depositSize,\n        int256 _sizeDelta,\n        bytes32 _marketKey\n    ) internal returns (uint256 marginMoved) {\n        // define market via _marketKey\n        IFuturesMarket market = futuresMarket(_marketKey);\n\n        /// @dev if _depositSize is not 0, then we must:\n        /// (1) impose correct fee\n        /// (2) transfer _depositSize (new margin) into the market\n        if (_depositSize > 0) {\n            /// @notice marginMoved used to calculate fee based on _depositSize\n            marginMoved = _abs(_depositSize);\n\n            // make sure committed margin isn't deposited\n            if (marginMoved > freeMargin()) {\n                revert InsufficientFreeMargin(freeMargin(), marginMoved);\n            }\n\n            /// @notice alter the amount of margin in specific market position\n            /// @dev positive input triggers a deposit; a negative one, a withdrawal\n            market.transferMargin(_depositSize);\n        }\n\n        /// @dev if _sizeDelta is 0, then we do not want to modify position size, only margin\n        if (_sizeDelta != 0) {\n            // modify position in specific market with KWENTA tracking code\n            market.modifyPositionWithTracking(_sizeDelta, TRACKING_CODE);\n        }\n\n        // fetch new position data from Synthetix\n        (, , uint128 margin, , int128 size) = market.positions(address(this));\n\n        // update state for given open market position\n        marginMoved += updateActiveMarketPosition(_marketKey, margin, size, market);\n    }\n\n    /// @notice modify active position and withdraw marginAsset from market into this account\n    /// @dev _withdrawalSize can NEVER be positive NOR zero\n    /// @dev _sizeDelta could be zero\n    /// @param _withdrawalSize: size of sUSD to withdraw from market into account\n    /// @param _sizeDelta: size and position type (long//short) denoted in market synth (ex: sETH)\n    /// @param _marketKey: synthetix futures market id/key\n    /// @return marginMoved total margin moved in function call\n    function modifyPositionForMarketAndWithdraw(\n        int256 _withdrawalSize,\n        int256 _sizeDelta,\n        bytes32 _marketKey\n    ) internal returns (uint256 marginMoved) {\n        // define market via _marketKey\n        IFuturesMarket market = futuresMarket(_marketKey);\n\n        /// @notice marginMoved used to calculate fee based on _withdrawalSize\n        marginMoved = _abs(_withdrawalSize);\n\n        /// @dev if _sizeDelta is 0, then we do not want to modify position size, only margin\n        if (_sizeDelta != 0) {\n            // modify position in specific market with KWENTA tracking code\n            market.modifyPositionWithTracking(_sizeDelta, TRACKING_CODE);\n        }\n\n        /// @notice alter the amount of margin in specific market position\n        /// @dev positive input triggers a deposit; a negative one, a withdrawal\n        market.transferMargin(_withdrawalSize);\n\n        // fetch new position data from Synthetix\n        (, , uint128 margin, , int128 size) = market.positions(address(this));\n\n        // update state for given open market position\n        marginMoved += updateActiveMarketPosition(_marketKey, margin, size, market);\n    }\n\n    /// @notice closes futures position and withdraws all margin in that market back to this account\n    /// @param _marketKey: synthetix futures market id/key\n    /// @return marginMoved total margin moved in function call\n    function closePositionAndWithdraw(bytes32 _marketKey)\n        internal\n        returns (uint256 marginMoved)\n    {\n        // update state (remove market)\n        removeActiveMarketPositon(_marketKey);\n\n        // define market via _marketKey\n        IFuturesMarket market = futuresMarket(_marketKey);\n\n        // close market position\n        market.closePosition();\n\n        // fetch position data from Synthetix\n        (, , uint128 margin, , ) = market.positions(address(this));\n\n        /// @notice marginMoved used to calculate fee based on margin in market being closed\n        marginMoved = margin;\n\n        // withdraw margin back to this account\n        market.withdrawAllMargin();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    Internal Account State Management\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice used internally to update contract state for the account's active position tracking\n    /// @dev parameters are generated and passed to this function via Synthetix Futures' contracts\n    /// @dev if _size becomes 0, remove position from account state and withdraw margin (only non-\"internal\" logic in below code)\n    /// @param _marketKey: key for synthetix futures market\n    /// @param _margin: amount of margin the specific market position has\n    /// @param _size: represents size of position (i.e. accounts for leverage)\n    /// @return marginMoved total margin moved in function call\n    function updateActiveMarketPosition(\n        bytes32 _marketKey,\n        uint128 _margin,\n        int128 _size,\n        IFuturesMarket market\n    ) internal returns (uint256 marginMoved) {\n        // if position size is 0, position is effectively closed on\n        // FuturesMarket but margin is still in contract, thus it must\n        // be withdrawn back to this account\n        if (_size == 0) {\n            // update state (remove market)\n            removeActiveMarketPositon(_marketKey);\n\n            /// @notice marginMoved used to calculate fee based on margin in market being closed\n            marginMoved = _margin;\n\n            // withdraw margin back to this account\n            market.withdrawAllMargin();\n            return marginMoved;\n        }\n\n        ActiveMarketPosition memory newPosition = ActiveMarketPosition(\n            _marketKey,\n            _margin,\n            _size\n        );\n\n        // check if this is updating a position or creating one\n        if (activeMarketPositions[_marketKey].marketKey == 0) {\n            activeMarketKeys.push(_marketKey);\n        }\n\n        // update state of active market positions\n        activeMarketPositions[_marketKey] = newPosition;\n    }\n\n    /// @notice used internally to remove active market position from contract's internal state\n    /// @param _marketKey: key for previously active market position\n    function removeActiveMarketPositon(bytes32 _marketKey) internal {\n        // ensure active market exists\n        if (activeMarketPositions[_marketKey].marketKey == 0) {\n            revert MissingMarketKey(_marketKey);\n        }\n\n        delete activeMarketPositions[_marketKey];\n        uint256 numberOfActiveMarkets = activeMarketKeys.length;\n\n        for (uint16 i = 0; i < numberOfActiveMarkets; i++) {\n            // once _marketKey is encountered, swap with\n            // last element in array and exit for-loop\n            if (activeMarketKeys[i] == _marketKey) {\n                /// @dev effectively removes _marketKey from activeMarketKeys\n                activeMarketKeys[i] = activeMarketKeys[\n                    numberOfActiveMarkets - 1\n                ];\n                break;\n            }\n        }\n        // remove last element now that it has been copied\n        activeMarketKeys.pop();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Internal Getter Utilities\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice addressResolver fetches IFuturesMarket address for specific market\n    /// @param _marketKey: key for synthetix futures market\n    /// @return IFuturesMarket contract interface\n    function futuresMarket(bytes32 _marketKey)\n        internal\n        view\n        returns (IFuturesMarket)\n    {\n        return IFuturesMarket(futuresManager.marketForKey(_marketKey));\n    }\n\n    /// @notice exchangeRates() fetches current ExchangeRates contract\n    function exchangeRates() internal view returns (IExchangeRates) {\n        return\n            IExchangeRates(\n                addressResolver.requireAndGetAddress(\n                    \"ExchangeRates\",\n                    \"MarginBase: Could not get ExchangeRates\"\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            Limit Orders\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice limit order logic condition checker\n    /// @param _orderId: key for an active order\n    function validOrder(uint256 _orderId) public view returns (bool) {\n        Order memory order = orders[_orderId];\n\n        bytes32 currencyKey = futuresMarket(order.marketKey).baseAsset();\n        // Get exchange rate for 1 unit\n        uint256 price = exchangeRates().effectiveValue(currencyKey, 1e18, SUSD);\n\n        if (order.sizeDelta > 0) {\n            // Long\n            return price <= order.desiredPrice;\n        } else if (order.sizeDelta < 0) {\n            // Short\n            return price >= order.desiredPrice;\n        } else {\n            revert(\"Order size 0\");\n        }\n    }\n\n    /// @notice register a limit order internally and with gelato\n    /// @param _marketKey: synthetix futures market id/key\n    /// @param _marginDelta: amount of margin (in sUSD) to deposit or withdraw\n    /// @param _sizeDelta: denoted in market currency (i.e. ETH, BTC, etc), size of futures position\n    /// @param _limitPrice: expected limit order price\n    /// @return orderId contract interface\n    function placeOrder(\n        bytes32 _marketKey,\n        int256 _marginDelta,\n        int256 _sizeDelta,\n        uint256 _limitPrice\n    ) external onlyOwner returns (uint256) {\n        // if more margin is desired on the position we must commit the margin\n        if (_marginDelta > 0) {\n            // ensure margin doesn't exceed max\n            if (_abs(_marginDelta) > freeMargin()) {\n                revert InsufficientFreeMargin(freeMargin(), _abs(_marginDelta));\n            }\n            committedMargin += _abs(_marginDelta);\n        }\n\n        bytes32 taskId = IOps(ops).createTask(\n            address(this), // execution function address\n            this.executeOrder.selector, // execution function selector\n            address(this), // checker (resolver) address\n            abi.encodeWithSelector(this.checker.selector, orderId) // checker (resolver) calldata\n        );\n\n        orders[orderId] = Order({\n            marketKey: _marketKey,\n            marginDelta: _marginDelta,\n            sizeDelta: _sizeDelta,\n            desiredPrice: _limitPrice,\n            gelatoTaskId: taskId\n        });\n\n        return orderId++;\n    }\n\n    /// @notice cancel a gelato queued order\n    /// @param _orderId: key for an active order\n    function cancelOrder(uint256 _orderId) external onlyOwner {\n        Order memory order = orders[_orderId];\n\n        // if margin was committed, free it\n        if (order.marginDelta > 0) {\n            committedMargin -= _abs(order.marginDelta);\n        }\n        IOps(ops).cancelTask(order.gelatoTaskId);\n\n        // delete order from orders\n        delete orders[_orderId];\n    }\n\n    /// @notice execute a gelato queued order\n    /// @notice only keepers can trigger this function\n    /// @param _orderId: key for an active order\n    function executeOrder(uint256 _orderId) external onlyOps {\n        require(validOrder(_orderId), \"Order not ready for execution\");\n        Order memory order = orders[_orderId];\n\n        // if margin was committed, free it\n        if (order.marginDelta > 0) {\n            committedMargin -= _abs(order.marginDelta);\n        }\n\n        // prep new position\n        MarginBase.UpdateMarketPositionSpec[]\n            memory newPositions = new MarginBase.UpdateMarketPositionSpec[](1);\n        newPositions[0] = MarginBase.UpdateMarketPositionSpec(\n            order.marketKey,\n            order.marginDelta,\n            order.sizeDelta,\n            false // assume the position will be closed if the limit order is the opposite size\n        );\n\n        // delete order from orders\n        delete orders[_orderId];\n\n        // execute trade\n        _distributeMargin(newPositions);\n\n        // pay fee\n        (uint256 fee, address feeToken) = IOps(ops).getFeeDetails();\n        _transfer(fee, feeToken);\n    }\n\n    /// @notice signal to a keeper that an order is valid/invalid for execution\n    /// @param _orderId: key for an active order\n    /// @return canExec boolean that signals to keeper an order can be executed\n    /// @return execPayload calldata for executing an order\n    function checker(uint256 _orderId)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        canExec = validOrder(_orderId);\n        // calldata for execute func\n        execPayload = abi.encodeWithSelector(\n            this.executeOrder.selector,\n            _orderId\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    Utility Functions\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice Absolute value of the input, returned as an unsigned number.\n    /// @param x: signed number\n    function _abs(int256 x) internal pure returns (uint256) {\n        return uint256(x < 0 ? -x : x);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IFuturesMarket.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport \"./IFuturesMarketBaseTypes.sol\";\n\ninterface IFuturesMarket {\n    /* ========== FUNCTION INTERFACE ========== */\n\n    /* ---------- Market Details ---------- */\n\n    function marketKey() external view returns (bytes32 key);\n\n    function baseAsset() external view returns (bytes32 key);\n\n    function marketSize() external view returns (uint128 size);\n\n    function marketSkew() external view returns (int128 skew);\n\n    function fundingLastRecomputed() external view returns (uint32 timestamp);\n\n    function fundingSequence(uint index) external view returns (int128 netFunding);\n\n    function positions(address account)\n        external\n        view\n        returns (\n            uint64 id,\n            uint64 fundingIndex,\n            uint128 margin,\n            uint128 lastPrice,\n            int128 size\n        );\n\n    function assetPrice() external view returns (uint price, bool invalid);\n\n    function marketSizes() external view returns (uint long, uint short);\n\n    function marketDebt() external view returns (uint debt, bool isInvalid);\n\n    function currentFundingRate() external view returns (int fundingRate);\n\n    function unrecordedFunding() external view returns (int funding, bool invalid);\n\n    function fundingSequenceLength() external view returns (uint length);\n\n    /* ---------- Position Details ---------- */\n\n    function notionalValue(address account) external view returns (int value, bool invalid);\n\n    function profitLoss(address account) external view returns (int pnl, bool invalid);\n\n    function accruedFunding(address account) external view returns (int funding, bool invalid);\n\n    function remainingMargin(address account) external view returns (uint marginRemaining, bool invalid);\n\n    function accessibleMargin(address account) external view returns (uint marginAccessible, bool invalid);\n\n    function liquidationPrice(address account) external view returns (uint price, bool invalid);\n\n    function liquidationFee(address account) external view returns (uint);\n\n    function canLiquidate(address account) external view returns (bool);\n\n    function orderFee(int sizeDelta) external view returns (uint fee, bool invalid);\n\n    function postTradeDetails(int sizeDelta, address sender)\n        external\n        view\n        returns (\n            uint margin,\n            int size,\n            uint price,\n            uint liqPrice,\n            uint fee,\n            IFuturesMarketBaseTypes.Status status\n        );\n\n    /* ---------- Market Operations ---------- */\n\n    function recomputeFunding() external returns (uint lastIndex);\n\n    function transferMargin(int marginDelta) external;\n\n    function withdrawAllMargin() external;\n\n    function modifyPosition(int sizeDelta) external;\n\n    function modifyPositionWithTracking(int sizeDelta, bytes32 trackingCode) external;\n\n    function submitNextPriceOrder(int sizeDelta) external;\n\n    function submitNextPriceOrderWithTracking(int sizeDelta, bytes32 trackingCode) external;\n\n    function cancelNextPriceOrder(address account) external;\n\n    function executeNextPriceOrder(address account) external;\n\n    function closePosition() external;\n\n    function closePositionWithTracking(bytes32 trackingCode) external;\n\n    function liquidatePosition(address account) external;\n}\n"
    },
    "contracts/interfaces/IFuturesMarketManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\ninterface IFuturesMarketManager {\n    function markets(uint index, uint pageSize) external view returns (address[] memory);\n\n    function numMarkets() external view returns (uint);\n\n    function allMarkets() external view returns (address[] memory);\n\n    function marketForKey(bytes32 marketKey) external view returns (address);\n\n    function marketsForKeys(bytes32[] calldata marketKeys) external view returns (address[] memory);\n\n    function totalDebt() external view returns (uint debt, bool isInvalid);\n}"
    },
    "contracts/interfaces/IExchangeRates.sol": {
      "content": "pragma solidity >=0.4.24;\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\ninterface IExchangeRates {\n    // Structs\n    struct RateAndUpdatedTime {\n        uint216 rate;\n        uint40 time;\n    }\n\n    // Views\n    function aggregators(bytes32 currencyKey) external view returns (address);\n\n    function aggregatorWarningFlags() external view returns (address);\n\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\n\n    function anyRateIsInvalidAtRound(bytes32[] calldata currencyKeys, uint[] calldata roundIds) external view returns (bool);\n\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\n\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value);\n\n    function effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveValueAndRatesAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveAtomicValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint systemValue,\n            uint systemSourceRate,\n            uint systemDestinationRate\n        );\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint);\n\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\n\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\n\n    function rateStalePeriod() external view returns (uint);\n\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(\n        bytes32 currencyKey,\n        uint numRounds,\n        uint roundId\n    ) external view returns (uint[] memory rates, uint[] memory times);\n\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (uint[] memory rates, bool anyRateInvalid);\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\n\n    function synthTooVolatileForAtomicExchange(bytes32 currencyKey) external view returns (bool);\n}\n"
    },
    "contracts/utils/OpsReady.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {\n    SafeERC20,\n    IERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IOps {\n    function gelato() external view returns (address payable);\n    \n    function createTask(\n        address _execAddress,\n        bytes4 _execSelector,\n        address _resolverAddress,\n        bytes calldata _resolverData\n    ) external returns (bytes32 task);\n\n    function cancelTask(bytes32 _taskId) external;\n\n    function getFeeDetails() external view returns (uint256, address);\n}\n\nabstract contract OpsReady {\n    address public ops;\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    modifier onlyOps() {\n        require(msg.sender == ops, \"OpsReady: onlyOps\");\n        _;\n    }\n\n    function gelato() public view returns (address payable) {\n        return IOps(ops).gelato();\n    }\n\n    function _transfer(uint256 _amount, address _paymentToken) internal {\n        if (_paymentToken == ETH) {\n            (bool success, ) = gelato().call{value: _amount}(\"\");\n            require(success, \"_transfer: ETH transfer failed\");\n        } else {\n            SafeERC20.safeTransfer(IERC20(_paymentToken), gelato(), _amount);\n        }\n    }\n}"
    },
    "contracts/utils/MinimalProxyable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MinimalProxyable is Ownable {\n\n    bool masterCopy;\n    bool initialized;\n\n    constructor() {\n        masterCopy = true;\n    }\n\n    function initialize() public initOnce {}\n\n    modifier initOnce {\n        require(!masterCopy, \"Cannot initialize implementation\");\n        require(!initialized, \"Already initialized\");\n        initialized = true;\n        _;\n    }\n\n}"
    },
    "contracts/MarginBaseSettings.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Kwenta Settings for MarginBase Accounts\n/// @author JaredBorders (jaredborders@proton.me), JChiaramonte7 (jeremy@bytecode.llc)\n/// @notice Contract (owned by the deployer) for controlling the settings of MarginBase account(s)\n/// @dev This contract will require deployment prior to MarginBase account creation\ncontract MarginBaseSettings is Ownable {\n    /*///////////////////////////////////////////////////////////////\n                                Constants\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice decimals calculations\n    uint256 private constant MAX_BPS = 10000;\n\n    /*///////////////////////////////////////////////////////////////\n                        Settings\n    ///////////////////////////////////////////////////////////////*/\n\n    // @notice Kwenta's Treasury Address\n    address public treasury;\n\n    /// @notice denoted in Basis points (BPS) (One basis point is equal to 1/100th of 1%)\n    /// @dev fee imposed on calls to distributeMargin()\n    uint256 public distributionFee;\n\n    /// @notice denoted in Basis points (BPS) (One basis point is equal to 1/100th of 1%)\n    /// @dev fee imposed on limit orders\n    uint256 public limitOrderFee;\n\n    /// @notice denoted in Basis points (BPS) (One basis point is equal to 1/100th of 1%)\n    /// @dev fee imposed on stop losses\n    uint256 public stopLossFee;\n\n    /*///////////////////////////////////////////////////////////////\n                                Events\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted after changing treasury address\n    /// @param treasury: new treasury address\n    event TreasuryAddressChanged(address treasury);\n\n    /// @notice emitted after a successful distribution fee change\n    /// @param fee: fee denoted in BPS\n    event DistributionFeeChanged(uint256 fee);\n\n    /// @notice emitted after a successful limit order fee change\n    /// @param fee: fee denoted in BPS\n    event LimitOrderFeeChanged(uint256 fee);\n\n    /// @notice emitted after a successful stop loss fee change\n    /// @param fee: fee denoted in BPS\n    event StopLossFeeChanged(uint256 fee);\n\n    /*///////////////////////////////////////////////////////////////\n                                Errors\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice zero address cannot be used\n    error ZeroAddress();\n\n    /// @notice invalid distribution fee\n    /// @param fee: fee denoted in BPS\n    error InvalidDistributionFee(uint256 fee);\n\n    /// @notice invalid limit order fee\n    /// @param fee: fee denoted in BPS\n    error InvalidLimitOrderFee(uint256 fee);\n\n    /// @notice invalid stop loss fee\n    /// @param fee: fee denoted in BPS\n    error InvalidStopLossFee(uint256 fee);\n\n    /*///////////////////////////////////////////////////////////////\n                            Constructor\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice set initial fee imposed on calls to MarginBase.distributeMargin()\n    /// @param _treasury: Kwenta's Treasury Address\n    /// @param _distributionFee: fee denoted in BPS\n    /// @param _limitOrderFee: fee denoted in BPS\n    /// @param _stopLossFee: fee denoted in BPS\n    constructor(\n        address _treasury,\n        uint256 _distributionFee,\n        uint256 _limitOrderFee,\n        uint256 _stopLossFee\n    ) {\n        /// @notice ensure valid address for Kwenta Treasury\n        if (_treasury == address(0)) { revert ZeroAddress(); }\n        \n        /// @notice set Kwenta Treasury address \n        treasury = _treasury;\n\n        /// @notice ensure valid fees\n        if (_distributionFee >= MAX_BPS) { revert InvalidDistributionFee(_distributionFee); }\n        if (_limitOrderFee >= MAX_BPS) { revert InvalidLimitOrderFee(_limitOrderFee); }\n        if (_stopLossFee >= MAX_BPS) { revert InvalidStopLossFee(_stopLossFee); }\n\n        /// @notice set initial fees\n        distributionFee = _distributionFee;\n        limitOrderFee = _limitOrderFee;\n        stopLossFee = _stopLossFee;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                Setters\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice set new treasury address\n    /// @param _treasury: new treasury address\n    function setTreasury(address _treasury) external onlyOwner {\n        /// @notice ensure valid address for Kwenta Treasury\n        if (_treasury == address(0)) { revert ZeroAddress(); }\n\n        /// @notice set Kwenta Treasury address\n        treasury = _treasury;\n\n        emit TreasuryAddressChanged(_treasury);\n    }\n\n    /// @notice set new distribution fee\n    /// @param _fee: fee denoted in BPS\n    function setDistributionFee(uint256 _fee) external onlyOwner {\n        /// @notice ensure valid fee\n        if (_fee >= MAX_BPS) { revert InvalidDistributionFee(_fee); }\n\n        /// @notice set fee\n        distributionFee = _fee;\n\n        emit DistributionFeeChanged(distributionFee);\n    }\n\n    /// @notice set new limit order fee\n    /// @param _fee: fee denoted in BPS\n    function setLimitOrderFee(uint256 _fee) external onlyOwner {\n        /// @notice ensure valid fee\n        if (_fee >= MAX_BPS) { revert InvalidLimitOrderFee(_fee); }\n\n        /// @notice set fee\n        limitOrderFee = _fee;\n\n        emit LimitOrderFeeChanged(limitOrderFee);\n    }\n\n    /// @notice set new stop loss fee\n    /// @param _fee: fee denoted in BPS\n    function setStopLossFee(uint256 _fee) external onlyOwner {\n        /// @notice ensure valid fee\n        if (_fee >= MAX_BPS) { revert InvalidStopLossFee(_fee); }\n\n        /// @notice set fee\n        stopLossFee = _fee;\n\n        emit StopLossFeeChanged(stopLossFee);\n    }\n}\n"
    },
    "contracts/interfaces/IFuturesMarketBaseTypes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\ninterface IFuturesMarketBaseTypes {\n    /* ========== TYPES ========== */\n\n    enum Status {\n        Ok,\n        InvalidPrice,\n        PriceOutOfBounds,\n        CanLiquidate,\n        CannotLiquidate,\n        MaxMarketSizeExceeded,\n        MaxLeverageExceeded,\n        InsufficientMargin,\n        NotPermitted,\n        NilOrder,\n        NoPositionOpen,\n        PriceTooVolatile\n    }\n\n    // If margin/size are positive, the position is long; if negative then it is short.\n    struct Position {\n        uint64 id;\n        uint64 lastFundingIndex;\n        uint128 margin;\n        uint128 lastPrice;\n        int128 size;\n    }\n\n    // next-price order storage\n    struct NextPriceOrder {\n        int128 sizeDelta; // difference in position to pass to modifyPosition\n        uint128 targetRoundId; // price oracle roundId using which price this order needs to exucted\n        uint128 commitDeposit; // the commitDeposit paid upon submitting that needs to be refunded if order succeeds\n        uint128 keeperDeposit; // the keeperDeposit paid upon submitting that needs to be paid / refunded on tx confirmation\n        bytes32 trackingCode; // tracking code to emit on execution for volume source fee sharing\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/MarginAccountFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"./utils/MinimalProxyFactory.sol\";\nimport \"./MarginBase.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Kwenta MarginBase Factory\n/// @author JaredBorders (jaredborders@proton.me), JChiaramonte7 (jeremy@bytecode.llc)\n/// @notice Factory which enables deploying a MarginBase account for any user \ncontract MarginAccountFactory is MinimalProxyFactory {\n    \n    string public version; // format: (0.1.0)\n\n    /*///////////////////////////////////////////////////////////////\n                                Immutables\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice MarginBase contract acting as user's account\n    MarginBase public immutable implementation;\n\n    /// @notice ERC20 token used to interact with markets\n    IERC20 public immutable marginAsset;\n\n    /// @notice synthetix address resolver\n    address public immutable addressResolver;\n\n    /// @notice settings for MarginBase accounts\n    address public marginBaseSettings;\n    \n    /// @notice gelato ops\n    address payable public immutable ops;\n\n    /*///////////////////////////////////////////////////////////////\n                                Events\n    ///////////////////////////////////////////////////////////////*/\n\n    event NewAccount(address indexed owner, address account);\n\n    /*///////////////////////////////////////////////////////////////\n                                Constructor\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice deploy MarginBase implementation to later be cloned\n    /// @param _version: version of contract\n    /// @param _marginAsset: token contract address used for account margin\n    /// @param _addressResolver: contract address for synthetix address resolver\n    /// @param _marginBaseSettings: contract address for MarginBase account settings\n    /// @param _ops: contract address for gelato ops -- must be payable\n    constructor(\n        string memory _version,\n        address _marginAsset,\n        address _addressResolver,\n        address _marginBaseSettings,\n        address payable _ops\n    ) {\n        version = _version;\n        implementation = new MarginBase();\n        marginAsset = IERC20(_marginAsset);\n        addressResolver = _addressResolver;\n\n        /// @dev MarginBaseSettings must exist prior to MarginAccountFactory\n        marginBaseSettings = _marginBaseSettings;\n\n        ops = _ops;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            Account Deployment\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice clone MarginBase (i.e. create new account for user)\n    /// @dev this contract is the initial owner of cloned MarginBase,\n    /// but ownership is transferred after successful initialization\n    function newAccount() external returns (address) {\n        MarginBase account = MarginBase(\n            _cloneAsMinimalProxy(address(implementation), \"Creation failure\")\n        );\n        account.initialize(address(marginAsset), addressResolver, marginBaseSettings, ops);\n        account.transferOwnership(msg.sender);\n\n        emit NewAccount(msg.sender, address(account));\n        return address(account);\n    }\n}\n"
    },
    "contracts/utils/MinimalProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\ncontract MinimalProxyFactory {\n    function _cloneAsMinimalProxy(address _base, string memory _revertMsg)\n        internal\n        returns (address clone)\n    {\n        bytes memory createData = _generateMinimalProxyCreateData(_base);\n\n        assembly {\n            clone := create(\n                0, // no value\n                add(createData, 0x20), // data\n                55 // data is always 55 bytes (10 constructor + 45 code)\n            )\n        }\n\n        // If CREATE fails for some reason, address(0) is returned\n        require(clone != address(0), _revertMsg);\n    }\n\n    function _generateMinimalProxyCreateData(address _base)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                //---- constructor -----\n                bytes10(0x3d602d80600a3d3981f3),\n                //---- proxy code -----\n                bytes10(0x363d3d373d3d3d363d73),\n                _base,\n                bytes15(0x5af43d82803e903d91602b57fd5bf3)\n            );\n    }\n}"
    },
    "contracts/interfaces/ISynth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}